name: selenium-manager-ci

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true
      github_environment:
        required: false
        type: string
    secrets:
      docker-user:
        required: true
      docker-pass:
        required: true
      docker-repo:
        required: true
      github-token:
        required: true
      vps-host:
        required: true
      vps-username:
        required: true
      vps-ssh-private-key:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  build_and_publish:
    name: Build, Package and Publish
    runs-on: ubuntu-latest
    outputs:
      APP_VERSION: ${{ steps.versioning.outputs.APP_VERSION }}
      JSON_B64: ${{ steps.replace_secrets.outputs.JSON_B64 }}
      APP_NAME: ${{ steps.json_config.outputs.APP_NAME }}
      APP_PORT: ${{ steps.json_config.outputs.APP_PORT }}
    steps:

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read config.json
        id: json_config
        run: |
          ENV_NAME=${{ inputs.environment }}
          CONFIG_PATH="infra/$ENV_NAME/config.json"

          sudo apt-get update && sudo apt-get install -y jq
          APP_NAME=$(jq -r '.nameAPP' "$CONFIG_PATH")
          APP_PORT=$(jq -r '.port[] | "-p \(. )"' "$CONFIG_PATH" | xargs)

          echo "APP_NAME=$APP_NAME" >> $GITHUB_OUTPUT
          echo "APP_PORT=$APP_PORT" >> $GITHUB_OUTPUT

      - name: Replace Secrets
        id: replace_secrets
        env:
          ENV_NAME: ${{ inputs.environment }}
        run: |
          JSON_CONFIG=$(cat infra/$ENV_NAME/config.json)
          JSON_B64=$(echo "$JSON_CONFIG" | base64 -w0 2>/dev/null || echo "$JSON_CONFIG" | base64)
          echo "JSON_B64=$JSON_B64" >> $GITHUB_OUTPUT

      - name: Set Version
        id: versioning
        run: |
          NEW_VERSION="1.0.${{ github.run_number }}"
          echo "APP_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.docker-user }}
          password: ${{ secrets.docker-pass }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.docker-repo }}/${{ steps.json_config.outputs.APP_NAME }}:${{ steps.versioning.outputs.APP_VERSION }}
            ${{ secrets.docker-repo }}/${{ steps.json_config.outputs.APP_NAME }}:latest

  deploy:
    name: Deploy + Healthcheck
    runs-on: ubuntu-latest
    needs: [ build_and_publish ]

    steps:
      - name: Deploy & Healthcheck on VPS
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.vps-host }}
          username: ${{ secrets.vps-username }}
          key: ${{ secrets.vps-ssh-private-key }}
          script: |
            set -euo pipefail

            APP_VERSION="${{ needs.build_and_publish.outputs.APP_VERSION }}"
            JSON_B64='${{ needs.build_and_publish.outputs.JSON_B64 }}'
            APP_NAME="${{ needs.build_and_publish.outputs.APP_NAME }}"
            APP_PORT="${{ needs.build_and_publish.outputs.APP_PORT }}"
            REPO_DOCKER="${{ secrets.docker-repo }}"
            IMAGE_NAME="$REPO_DOCKER/$APP_NAME:$APP_VERSION"

            echo "üìÑ Decodificando config.json"
            JSON_CONFIG=$(echo "$JSON_B64" | base64 -d)

            echo "üì¶ Montando volumes (se houver)"
            DOCKER_VOLUMES=$(echo "$JSON_CONFIG" | jq -r '.volumes[]? | "-v \(. )"' | xargs)
            echo "   Volumes: $DOCKER_VOLUMES"

            # Extrai configs com fallback
            CPUS=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .cpus // "1.0"')
            MEMORY=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .memory // "800m"')
            MEMORY_SWAP=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .memorySwap // "1G"')
            
            echo "‚úÖ Config extra√≠da:"
            echo "   CPUs: $CPUS"
            echo "   Memory: $MEMORY"
            echo "   Memory Swap: $MEMORY_SWAP"

            # ----- Preparar env -----
            TMP_DIR=$(mktemp -d)
            ENV_FILE="$TMP_DIR/$APP_NAME/.env"
            mkdir -p "$(dirname "$ENV_FILE")"
            echo "$JSON_CONFIG" | jq -r '.environment[] | "\(.name)=\(.value)"' > "$ENV_FILE"

            # ----- Remover container antigo -----
            if docker ps -aq -f name="^${APP_NAME}$" >/dev/null; then
                docker stop "$APP_NAME" || true
                docker rm "$APP_NAME" || true
            fi

            # ----- Remover imagens antigas -----
            OLD=$(docker images -q "$REPO_DOCKER/$APP_NAME" || true)
            [ -n "$OLD" ] && docker rmi -f $OLD || true

            # ----- Criar novo container -----
            echo "üöÄ Subindo container..."
            docker run -d \
              $APP_PORT \
              --name "$APP_NAME" \
              --network "$(echo "$JSON_CONFIG" | jq -r '.network')" \
              --cpus="$CPUS" \
              --memory="$MEMORY" \
              --memory-swap="$MEMORY_SWAP" \
              --restart always \
              --env-file "$ENV_FILE" \
              $DOCKER_VOLUMES \
              "$IMAGE_NAME"

            rm -rf "$TMP_DIR"
      
      - name: Remote Healthcheck (via vps-host)
        run: |
          set -euo pipefail
          
          BASE="http://${{ secrets.vps-host }}:10000"

          echo "üì° Testando $BASE/status..."

          STATUS=$(curl -s -w "\n%{http_code}" "$BASE/status" || true)
          BODY=$(echo "$STATUS" | head -n1)
          CODE=$(echo "$STATUS" | tail -n1)

          echo "STATUS CODE: $CODE"
          echo "BODY: $BODY"

          if [ "$CODE" -ne 200 ]; then
            echo "‚ùå /status falhou (HTTP $CODE)"
            exit 1
          fi

          OK_VALUE=$(echo "$BODY" | jq -r '.ok')

          if [ "$OK_VALUE" != "false" ]; then
            echo "‚ùå Esperado ok=false no /status ‚Äî retornou $OK_VALUE"
            exit 1
          fi

          echo "üü° Selenium parado ‚Äî chamando /start remoto..."

          START=$(curl -s -w "\n%{http_code}" -X POST "$BASE/start")
          S_BODY=$(echo "$START" | head -n1)
          S_CODE=$(echo "$START" | tail -n1)

          echo "START CODE: $S_CODE"
          echo "START BODY: $S_BODY"

          if [ "$S_CODE" -ne 200 ]; then
            echo "‚ùå /start falhou (HTTP $S_CODE)"
            exit 1
          fi

          START_OK=$(echo "$S_BODY" | jq -r '.ok')
          if [ "$START_OK" != "true" ]; then
            echo "‚ùå Esperado ok=true ap√≥s /start ‚Äî retornou $START_OK"
            exit 1
          fi

          echo "üü¢ Selenium iniciou ‚Äî chamando /stop remoto..."

          STOP=$(curl -s -w "\n%{http_code}" -X POST "$BASE/stop")
          ST_BODY=$(echo "$STOP" | head -n1)
          ST_CODE=$(echo "$STOP" | tail -n1)

          echo "STOP CODE: $ST_CODE"
          echo "STOP BODY: $ST_BODY"

          STOPPED=$(echo "$ST_BODY" | jq -r '.stopped')
          if [ "$STOPPED" != "true" ]; then
            echo "‚ùå Esperado stopped=true ‚Äî retornou $STOPPED"
            exit 1
          fi

          echo "üéâ HEALTHCHECK REMOTO OK ‚Äî VPS respondendo perfeitamente!"  
