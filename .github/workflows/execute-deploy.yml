name: selenium-manager-ci

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true
      github_environment:
        required: false
        type: string
    secrets:
      docker-user:
        required: true
      docker-pass:
        required: true
      docker-repo:
        required: true
      github-token:
        required: true
      vps-host:
        required: true
      vps-username:
        required: true
      vps-ssh-private-key:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  build_and_publish:
    name: Build, Package and Publish
    runs-on: ubuntu-latest
    outputs:
      APP_VERSION: ${{ steps.versioning.outputs.APP_VERSION }}
      JSON_B64: ${{ steps.replace_secrets.outputs.JSON_B64 }}
      APP_NAME: ${{ steps.json_config.outputs.APP_NAME }}
      APP_PORT: ${{ steps.json_config.outputs.APP_PORT }}
    steps:

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read config.json
        id: json_config
        run: |
          ENV_NAME=${{ inputs.environment }}
          CONFIG_PATH="infra/$ENV_NAME/config.json"

          sudo apt-get update && sudo apt-get install -y jq
          APP_NAME=$(jq -r '.nameAPP' "$CONFIG_PATH")
          APP_PORT=$(jq -r '.port[] | "-p \(. )"' "$CONFIG_PATH" | xargs)

          echo "APP_NAME=$APP_NAME" >> $GITHUB_OUTPUT
          echo "APP_PORT=$APP_PORT" >> $GITHUB_OUTPUT

      - name: Replace Secrets
        id: replace_secrets
        env:
          ENV_NAME: ${{ inputs.environment }}
        run: |
          JSON_CONFIG=$(cat infra/$ENV_NAME/config.json)
          JSON_B64=$(echo "$JSON_CONFIG" | base64 -w0 2>/dev/null || echo "$JSON_CONFIG" | base64)
          echo "JSON_B64=$JSON_B64" >> $GITHUB_OUTPUT

      - name: Set Version
        id: versioning
        run: |
          NEW_VERSION="1.0.${{ github.run_number }}"
          echo "APP_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.docker-user }}
          password: ${{ secrets.docker-pass }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.docker-repo }}/${{ steps.json_config.outputs.APP_NAME }}:${{ steps.versioning.outputs.APP_VERSION }}
            ${{ secrets.docker-repo }}/${{ steps.json_config.outputs.APP_NAME }}:latest

  deploy:
    name: Deploy + Healthcheck
    runs-on: ubuntu-latest
    needs: [ build_and_publish ]

    steps:
      - name: Deploy & Healthcheck on VPS
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.vps-host }}
          username: ${{ secrets.vps-username }}
          key: ${{ secrets.vps-ssh-private-key }}
          script: |
            set -euo pipefail

            APP_VERSION="${{ needs.build_and_publish.outputs.APP_VERSION }}"
            JSON_B64='${{ needs.build_and_publish.outputs.JSON_B64 }}'
            APP_NAME="${{ needs.build_and_publish.outputs.APP_NAME }}"
            APP_PORT="${{ needs.build_and_publish.outputs.APP_PORT }}"
            REPO_DOCKER="${{ secrets.docker-repo }}"
            IMAGE_NAME="$REPO_DOCKER/$APP_NAME:$APP_VERSION"

            echo "üìÑ Decodificando config.json"
            JSON_CONFIG=$(echo "$JSON_B64" | base64 -d)

            echo "üì¶ Montando volumes (se houver)"
            DOCKER_VOLUMES=$(echo "$JSON_CONFIG" | jq -r '.volumes[]? | "-v \(. )"' | xargs)
            echo "   Volumes: $DOCKER_VOLUMES"

            # Extrai configs com fallback
            CPUS=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .cpus // "1.0"')
            MEMORY=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .memory // "800m"')
            MEMORY_SWAP=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .memorySwap // "1G"')
            
            echo "‚úÖ Config extra√≠da:"
            echo "   CPUs: $CPUS"
            echo "   Memory: $MEMORY"
            echo "   Memory Swap: $MEMORY_SWAP"

            # ----- Preparar env -----
            TMP_DIR=$(mktemp -d)
            ENV_FILE="$TMP_DIR/$APP_NAME/.env"
            mkdir -p "$(dirname "$ENV_FILE")"
            echo "$JSON_CONFIG" | jq -r '.environment[] | "\(.name)=\(.value)"' > "$ENV_FILE"

            # ----- Remover container antigo -----
            if docker ps -aq -f name="^${APP_NAME}$" >/dev/null; then
                docker stop "$APP_NAME" || true
                docker rm "$APP_NAME" || true
            fi

            # ----- Remover imagens antigas -----
            OLD=$(docker images -q "$REPO_DOCKER/$APP_NAME" || true)
            [ -n "$OLD" ] && docker rmi -f $OLD || true

            # ----- Criar novo container -----
            echo "üöÄ Subindo container..."
            docker run -d \
              $APP_PORT \
              --name "$APP_NAME" \
              --network "$(echo "$JSON_CONFIG" | jq -r '.network')" \
              --cpus="$CPUS" \
              --memory="$MEMORY" \
              --memory-swap="$MEMORY_SWAP" \
              --restart always \
              --env-file "$ENV_FILE" \
              $DOCKER_VOLUMES \
              "$IMAGE_NAME"

            rm -rf "$TMP_DIR"

            # =====================================================
            #              HEALTHCHECK (executado no VPS)
            # =====================================================

            BASE_URL="http://localhost:10000"

            echo "‚è≥ Aguardando container ficar saud√°vel..."

            # Fun√ß√£o para esperar container subir
            wait_for_container() {
              local name="$1"
              local max_retries=15
              local attempt=1
              
              while [ $attempt -le $max_retries ]; do
                if docker ps --filter "name=^${name}$" --filter "status=running" | grep -q "$name"; then
                  echo "üü¢ Container est√° rodando"
                  return 0
                fi
                echo "‚è≥ ($attempt/$max_retries) Aguardando container iniciar..."
                sleep 2
                attempt=$((attempt+1))
              done
              echo "‚ùå Container n√£o ficou RUNNING a tempo"
              exit 1
            }

            wait_for_container "$APP_NAME"

            # ---------------------------
            # Fun√ß√£o robusta de chamada HTTP com retry e timeout
            # ---------------------------
            request_with_retry() {
              local method="$1"
              local url="$2"
              local expected_http="$3"
              local retries=10
              local attempt=1

              while [ $attempt -le $retries ]; do
                echo "üîé Tentando chamada ($attempt/$retries): $method $url"

                RESPONSE=$(curl -sS --max-time 4 -w "\n%{http_code}" -X "$method" "$url" || echo "")
                BODY=$(echo "$RESPONSE" | head -n1)
                CODE=$(echo "$RESPONSE" | tail -n1)

                # Validar se retorno √© JSON
                if ! echo "$BODY" | jq empty 2>/dev/null; then
                  echo "‚ö†Ô∏è Retorno inv√°lido ou n√£o-JSON"
                fi

                echo "‚û°Ô∏è HTTP: $CODE | BODY: $BODY"

                if [ "$CODE" -eq "$expected_http" ]; then
                  echo "$BODY"
                  return 0
                fi

                sleep $((attempt + 1))
                attempt=$((attempt+1))
              done

              echo "‚ùå Falha ap√≥s $retries tentativas ‚Äî Endpoint indispon√≠vel: $url"
              exit 1
            }

            echo "üì° Testando /status..."
            BODY=$(request_with_retry "GET" "$BASE_URL/status" 200)
            OK=$(echo "$BODY" | jq -r '.ok')

            if [ "$OK" != "false" ]; then
              echo "‚ùå /status deveria retornar ok=false, recebeu ok=$OK"
              exit 1
            fi

            echo "üü° Selenium parado ‚Äî prosseguindo para /start..."

            # ---------------------------
            # /start
            # ---------------------------
            S_BODY=$(request_with_retry "POST" "$BASE_URL/start" 200)
            START_OK=$(echo "$S_BODY" | jq -r '.ok')

            if [ "$START_OK" != "true" ]; then
              echo "‚ùå /start deveria retornar ok=true, recebeu $START_OK"
              exit 1
            fi

            echo "üü¢ Selenium iniciado ‚Äî testando /stop..."

            # ---------------------------
            # /stop
            # ---------------------------
            ST_BODY=$(request_with_retry "POST" "$BASE_URL/stop" 200)
            STOP_OK=$(echo "$ST_BODY" | jq -r '.stopped')

            if [ "$STOP_OK" != "true" ]; then
              echo "‚ùå /stop deveria retornar stopped=true, recebeu $STOP_OK"
              exit 1
            fi

            echo "üéâ HEALTHCHECK OK ‚Äî Selenium Manager validado com sucesso!"
