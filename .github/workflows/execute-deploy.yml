name: selenium-manager-ci

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true
      github_environment:
        required: false
        type: string
    secrets:
      docker-user:
        required: true
      docker-pass:
        required: true
      docker-repo:
        required: true
      github-token:
        required: true
      vps-host:
        required: true
      vps-username:
        required: true
      vps-ssh-private-key:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  build_and_publish:
    name: Build, Package and Publish
    runs-on: ubuntu-latest
    outputs:
      APP_VERSION: ${{ steps.versioning.outputs.APP_VERSION }}
      JSON_B64: ${{ steps.replace_secrets.outputs.JSON_B64 }}
      APP_NAME: ${{ steps.json_config.outputs.APP_NAME }}
      APP_PORT: ${{ steps.json_config.outputs.APP_PORT }}
    steps:

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read config.json
        id: json_config
        run: |
          ENV_NAME=${{ inputs.environment }}
          CONFIG_PATH="infra/$ENV_NAME/config.json"

          sudo apt-get update && sudo apt-get install -y jq
          APP_NAME=$(jq -r '.nameAPP' "$CONFIG_PATH")
          APP_PORT=$(jq -r '.port[] | "-p \(. )"' "$CONFIG_PATH" | xargs)

          echo "APP_NAME=$APP_NAME" >> $GITHUB_OUTPUT
          echo "APP_PORT=$APP_PORT" >> $GITHUB_OUTPUT

      - name: Replace Secrets
        id: replace_secrets
        env:
          ENV_NAME: ${{ inputs.environment }}
        run: |
          JSON_CONFIG=$(cat infra/$ENV_NAME/config.json)
          JSON_B64=$(echo "$JSON_CONFIG" | base64 -w0 2>/dev/null || echo "$JSON_CONFIG" | base64)
          echo "JSON_B64=$JSON_B64" >> $GITHUB_OUTPUT

      - name: Set Version
        id: versioning
        run: |
          NEW_VERSION="1.0.${{ github.run_number }}"
          echo "APP_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

      # - name: Set up Docker Buildx
      #   uses: docker/setup-buildx-action@v3

      # - name: Login DockerHub
      #   uses: docker/login-action@v3
      #   with:
      #     username: ${{ secrets.docker-user }}
      #     password: ${{ secrets.docker-pass }}

      # - name: Build and push image
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: .
      #     file: ./Dockerfile
      #     platforms: linux/amd64
      #     push: true
      #     tags: |
      #       ${{ secrets.docker-repo }}/${{ steps.json_config.outputs.APP_NAME }}:${{ steps.versioning.outputs.APP_VERSION }}
      #       ${{ secrets.docker-repo }}/${{ steps.json_config.outputs.APP_NAME }}:latest

  deploy:
    name: Deploy + Healthcheck
    runs-on: ubuntu-latest
    needs: [ build_and_publish ]

    steps:
      - name: Deploy & Healthcheck on VPS
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.vps-host }}
          username: ${{ secrets.vps-username }}
          key: ${{ secrets.vps-ssh-private-key }}
          script: |
            set -euo pipefail

            APP_VERSION="${{ needs.build_and_publish.outputs.APP_VERSION }}"
            JSON_B64='${{ needs.build_and_publish.outputs.JSON_B64 }}'
            APP_NAME="${{ needs.build_and_publish.outputs.APP_NAME }}"
            APP_PORT="${{ needs.build_and_publish.outputs.APP_PORT }}"
            REPO_DOCKER="${{ secrets.docker-repo }}"
            IMAGE_NAME="$REPO_DOCKER/$APP_NAME:$latest"

            echo "üìÑ Decodificando config.json"
            JSON_CONFIG=$(echo "$JSON_B64" | base64 -d)

            echo "üì¶ Montando volumes (se houver)"
            DOCKER_VOLUMES=$(echo "$JSON_CONFIG" | jq -r '.volumes[]? | "-v \(. )"' | xargs)
            echo "   Volumes: $DOCKER_VOLUMES"

            # Extrai configs com fallback
            CPUS=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .cpus // "1.0"')
            MEMORY=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .memory // "800m"')
            MEMORY_SWAP=$(echo "$JSON_CONFIG" | jq -r '.configContainer // {} | .memorySwap // "1G"')
            
            echo "‚úÖ Config extra√≠da:"
            echo "   CPUs: $CPUS"
            echo "   Memory: $MEMORY"
            echo "   Memory Swap: $MEMORY_SWAP"

            # ----- Preparar env -----
            TMP_DIR=$(mktemp -d)
            ENV_FILE="$TMP_DIR/$APP_NAME/.env"
            mkdir -p "$(dirname "$ENV_FILE")"
            echo "$JSON_CONFIG" | jq -r '.environment[] | "\(.name)=\(.value)"' > "$ENV_FILE"

            # ----- Remover container antigo -----
            if docker ps -aq -f name="^${APP_NAME}$" >/dev/null; then
                docker stop "$APP_NAME" || true
                docker rm "$APP_NAME" || true
            fi

            # ----- Remover imagens antigas -----
            OLD=$(docker images -q "$REPO_DOCKER/$APP_NAME" || true)
            [ -n "$OLD" ] && docker rmi -f $OLD || true

            # ----- Criar novo container -----
            echo "üöÄ Subindo container..."
            docker run -d \
              $APP_PORT \
              --name "$APP_NAME" \
              --network "$(echo "$JSON_CONFIG" | jq -r '.network')" \
              --cpus="$CPUS" \
              --memory="$MEMORY" \
              --memory-swap="$MEMORY_SWAP" \
              --restart always \
              --env-file "$ENV_FILE" \
              $DOCKER_VOLUMES \
              "$IMAGE_NAME"

            rm -rf "$TMP_DIR"

            # =====================================================
            #              HEALTHCHECK (executado no VPS)
            # =====================================================

            echo "ü©∫ Executando healthcheck externo"

            echo "User: $(whoami)"
            echo "Home: $HOME"
            ls -lha $HOME
            ls -lha /

            if bash "$HOME/healthcheck.sh"; then
              echo "üéâ HEALTHCHECK OK ‚Äî Pipeline conclu√≠do com sucesso!"
            else
              echo "‚ùå HEALTHCHECK FALHOU ‚Äî Pipeline encerrado com erro!"
              exit 1
            fi

            echo "üéâ HEALTHCHECK OK ‚Äî Selenium Manager validado com sucesso!"
